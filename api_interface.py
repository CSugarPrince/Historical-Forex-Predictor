import requests
import datetime
import pytz

# TODO: proper error-checking for get_historical_rates()
# TODO: implement logging for error messages generated by the API. replace print statement
# TODO: code input checking for get_historical_rates. ensure that input is valid date format.

##########################################################################################
# Fixer API methods
##########################################################################################
def get_fixer_historical_rates(date_string):
    """ requests historical data for a certain date. param should be string in 'YYYY-MM-DD' format. 
    Sample Request:
    http://data.fixer.io/api/2013-03-16?access_key=33812a4991adfc761da5f7e6ca032921&symbols=USD,AUD,CAD,PLN,MXN&format=1

    Sample Response:
    {
    "success":true,
    "timestamp":1363478399,
    "historical":true,
    "base":"EUR",
    "date":"2013-03-16",
    "rates":{
        "USD":1.307716,
        "AUD":1.256333,
        "CAD":1.333812,
        "PLN":4.150819,
        "MXN":16.259128
    }
    }
    """
    # convert date object to date string
    base_url = 'http://data.fixer.io/api/'
    endpoint = date_string
    url = base_url + endpoint
    payload = {'access_key': '33812a4991adfc761da5f7e6ca032921', 
                'symbols': 'USD,EUR,JPY,GBP,CHF'}

    r = None

    # try requests.get(), catch errors
    try:
        r = requests.get(url, params=payload)
    except Exception as e:
        print(e)

    
    if r is not None:
        # parse json response into python dictionary
        py_dict = r.json()
        if py_dict['success']:
            # if api successfully gave the information requested
            # add 'source' key, value to data
            py_dict['source'] = 'http://data.fixer.io/api/'
            return py_dict
        else:
            # if there is a failure on the api side of the request e.g. max amount of api calls reached...
            print('Error: {}: {}'.format(py_dict['error']['code'], py_dict['error']['type'])) # replace with log
            return None

    else:
        # return None if an error occured and the request failed 
        return None


def get_fixer_time_series(start_date, end_date):
    """ NO BUENO!!!: requests historical data for every day from start date to end date. params should be date strings 'YYYY-MM-DD' """
    
    # convert date strings into date objects
    start_date = datetime.datetime.strptime(start_date,'%Y-%m-%d').date()
    end_date = datetime.datetime.strptime(end_date,'%Y-%m-%d').date()

    time_series = []

    # print out every day between the start date and the end date
    for n in range(int((end_date - start_date).days) + 1):
        hr = get_fixer_historical_rates(str(start_date + datetime.timedelta(n)))
        if hr is not None:
            time_series.append(hr)

    return time_series 


##########################################################################################
# CurrencyLayer API methods
##########################################################################################
def get_openex_historical_rates(date_string):
    """ requests historical data for a certain date. param should be string in 'YYYY-MM-DD' format. 
    Sample Request:
    https://openexchangerates.org/api/historical/2001-02-16.json?app_id=15a6609699e74c94b7775d637c2decdd&symbols=USD,EUR,JPY,GBP,CHF

    Sample Response:
    {
    "disclaimer": "Usage subject to terms: https://openexchangerates.org/terms",
    "license": "https://openexchangerates.org/license",
    "timestamp": 982342800,
    "base": "USD",
    "rates": {
        "CHF": 1.680438,
        "EUR": 1.092882,
        "GBP": 0.689691,
        "JPY": 115.324806,
        "USD": 1
        }
    }

    Sample Error Response:
    https://openexchangerates.org/api/historical/1001-02-16.json?app_id=15a6609699e74c94b7775d637c2decdd&symbols=USD,EUR,JPY,GBP,CHF

    {
    "error": true,
    "status": 400,
    "message": "not_available",
    "description": "Historical rates for the requested date are not available - please try a different date, or contact support@openexchangerates.org."
    }
    """
    # convert date object to date string
    base_url = 'https://openexchangerates.org/api/'
    endpoint = 'historical/' + date_string + '.json'
    url = base_url + endpoint
    payload = {'app_id': '15a6609699e74c94b7775d637c2decdd', 
                'symbols': 'USD,EUR,JPY,GBP,CHF'}

    r = None

    # try requests.get(), catch errors
    try:
        r = requests.get(url, params=payload)
    except Exception as e:
        print(e)

    
    if r is not None:
        # parse json response into python dictionary
        py_dict = r.json()
        if 'error' not in py_dict:
            # if api successfully gave the information requested
            # add 'date' key to dictionary
            py_dict['date'] = date_string
            # add 'source' key, value to data
            py_dict['source'] = 'https://openexchangerates.org/api/'
            return py_dict
        else:
            # if there is a failure on the api side of the request e.g. max amount of api calls reached...
            print('Failed to get historical rates for {} from {}: Error {}: {}, {}'.format(date_string, base_url, 
                py_dict['status'], py_dict['message'], py_dict['description'])) # replace with log
            return None                

    else:
        # return None if an error occured and the request failed 
        return None   


if __name__ == "__main__":
    
    # manually calculate the start and end date for the collect historical data function
    start = '1999-01-01'
    end = '2018-06-04'
    
    # testing creating date object from a string
    d = '1999-01-14'
    date_obj = datetime.datetime.strptime(d,'%Y-%m-%d').date()

    # calculating date range based on openEx calls available
    d = datetime.date(2002, 3, 27)
    td = datetime.timedelta(days=980)
    d = d + td
    # end date = 2004-12-01

    print(d)
    

   

